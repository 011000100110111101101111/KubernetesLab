############################################################################################
# Assumptions
# You have deployed a cluster (Can use the ansible script in my Nexus-2.0 repo)
# CNI, CSI are setup, CNI is capable of firewalling
############################################################################################

# Required Dependencies, no error if already installed.
# - import_playbook: ../Metallb/basic.yml # Loadbalancer

- name: This is a playbook
  hosts: masters
  vars_files:
    - "./global-config.yml"
  vars:
    local_namespace: "{{ kali_entry_sshconfig_namespace }}"
    local_service_account: "{{ kali_entry_sshconfig_service_account }}"
    local_label: "{{ kali_entry_sshconfig_label }}"
    local_name: "{{ kali_entry_sshconfig_name }}"
    local_replicas: "{{ kali_entry_sshconfig_replicas }}"
    local_already_deployed_check: "{{ kali_entry_sshconfig_label }}"
    local_image: "{{ kali_entry_sshconfig_image }}"
    local_containerport: "{{ kali_entry_sshconfig_containerport }}"
    local_port: "{{ kali_entry_sshconfig_port }}"
    local_targetport: "{{ kali_entry_sshconfig_targetport }}"
    local_environments: "{{ kali_entry_sshconfig_env_args }}"
    local_container_args: "{{ kali_entry_sshconfig_container_args }}"
    local_role_rules: "{{ kali_entry_sshconfig_role_rules }}"
  become: true
  # Make sure to change this
  become_user: "{{ become_user_setting }}"
  tasks:
    # TODO: Issue with args formatting
    - name: Debug rendered YAML
      ansible.builtin.copy:
        dest: "/home/alex/test.yml"
        content: |
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: "{{ local_name }}"
            namespace: "{{ local_namespace }}"
            labels:
              app: "{{ local_label }}"
          spec:
            replicas: {{ local_replicas }}
            selector:
              matchLabels:
                app: "{{ local_label }}"
            template:
              metadata:
                labels:
                  app: "{{ local_label }}"
              spec:
                serviceAccountName: "{{ local_service_account }}"
                containers:
                  - image: "{{ local_image }}"
                    {% if local_environments -%}
                    env:
                      {{ local_environments | to_nice_yaml(indent=2) | indent(12) }}
                    {% endif -%}
                    {% if local_container_args -%}
                    args:
                      {{ local_container_args | to_nice_yaml(indent=4) | indent(12) }}
                    {% endif -%}
                    imagePullPolicy: Always
                    name: "{{ local_label }}"
                    ports:
                      - containerPort: {{ local_containerport }}
                        protocol: TCP
        mode: preserve
    - name: Pre-Launch Task ... Package already deployed?
      ansible.builtin.shell: |
        kubectl get namespace {{ local_namespace }} --ignore-not-found
      retries: 2
      delay: 8
      ignore_errors: true
      args:
        executable: /bin/bash
      register: local_already_deployed_check
      changed_when: local_already_deployed_check.rc != 0
    - name: Block Code
      when: local_already_deployed_check.stdout == ""
      block:
        - name: Pre-Launch Task ... Create Namespace "{{ local_label }}"
          ansible.builtin.shell: |
            kubectl create namespace "{{ local_namespace }}"
          args:
            executable: /bin/bash
        - name: Pre-Launch Task ... Create Service account
          ansible.builtin.shell: |
            kubectl apply -f - <<EOF
            apiVersion: v1
            kind: ServiceAccount
            metadata:
              name: "{{ local_service_account }}"
              namespace: "{{ local_namespace }}"
            EOF
          args:
            executable: /bin/bash
        - name: Create Role "{{ local_label }}"
          ansible.builtin.shell: |
            kubectl apply -f - <<EOF
            apiVersion: rbac.authorization.k8s.io/v1
            kind: Role
            metadata:
              name: {{ local_label }}-role
              namespace: "{{ local_namespace }}"
            rules:
            {% for rule in local_role_rules %}
            - apiGroups: {{ rule.apiGroups }}
              resources: {{ rule.resources }}
              verbs: {{ rule.verbs }}
            {% endfor %}
            EOF
          args:
            executable: /bin/bash
        - name: Create RoleBinding "{{ local_label }}"
          ansible.builtin.shell: |
            kubectl apply -f - <<EOF
            apiVersion: rbac.authorization.k8s.io/v1
            kind: RoleBinding
            metadata:
              name: {{ local_label }}-rolebinding
              namespace: "{{ local_namespace }}"
            subjects:
            - kind: ServiceAccount
              name: "{{ local_service_account }}"
              namespace: "{{ local_namespace }}"
            roleRef:
              kind: Role
              name: {{ local_label }}-role
              apiGroup: rbac.authorization.k8s.io
            EOF
          args:
            executable: /bin/bash
        - name: Pre-Launch Task ... Create Cluster Role Binding
          ansible.builtin.shell: |
            kubectl apply -f - <<EOF
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: "{{ local_service_account }}"
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: cluster-admin
            subjects:
              - kind: ServiceAccount
                name: "{{ local_service_account }}"
                namespace: "{{ local_namespace }}"
            EOF
          args:
            executable: /bin/bash
        - name: Launch Task ... Install "{{ local_label }}"
          ansible.builtin.shell: |
            kubectl apply -f - <<EOF
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: "{{ local_name }}"
              namespace: "{{ local_namespace }}"
              labels:
                app: "{{ local_label }}"
            spec:
              replicas: {{ local_replicas }}
              selector:
                matchLabels:
                  app: "{{ local_label }}"
              template:
                metadata:
                  labels:
                    app: "{{ local_label }}"
                spec:
                  serviceAccountName: "{{ local_service_account }}"
                  containers:
                    - image: "{{ local_image }}"
                      {% if local_environments -%}
                      env:
                        {{ local_environments | to_nice_yaml(indent=2) | indent(12) }}
                      {% endif -%}
                      {% if local_container_args -%}
                      args:
                        {{ local_container_args | to_nice_yaml(indent=4) | indent(12) }}
                      {% endif -%}
                      imagePullPolicy: Always
                      name: "{{ local_label }}"
                      ports:
                        - containerPort: {{ local_containerport }}
                          protocol: TCP
            EOF
          args:
            executable: /bin/bash
        - name: Launch Task ... Deploy Service "{{ local_label }}"
          ansible.builtin.shell: |
            kubectl apply -f - <<EOF
            apiVersion: v1
            kind: Service
            metadata:
              name: "{{ local_label }}"
              namespace: "{{ local_namespace }}"
            spec:
              selector:
                app: "{{ local_label }}"
              ports:
                - port: {{ local_port }}
                  protocol: TCP
                  targetPort: {{ local_targetport }}
              type: LoadBalancer
            EOF
          args:
            executable: /bin/bash
        - name: Grab Service IPS and store them remotely
          ansible.builtin.shell: >
            kubectl get svc -n "{{ local_namespace }}"
            -o jsonpath='{range .items[*]}{.metadata.name}{" -> "}{.status.loadBalancer.ingress[*].ip}{"\n"}{end}'
            > ~/remoteips.txt
        - name: Fetch Remote IPS
          ansible.builtin.fetch:
            src: ~/remoteips.txt
            dest: ~/localips.txt
            flat: true
        - name: Debug
          ansible.builtin.debug:
            var: command_result.stdout
